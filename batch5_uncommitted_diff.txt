diff --git a/chrome-extension-app/src/background/index.js b/chrome-extension-app/src/background/index.js
index b44d008..89df527 100644
--- a/chrome-extension-app/src/background/index.js
+++ b/chrome-extension-app/src/background/index.js
@@ -576,6 +576,145 @@ console.log('  - exitTestMode(cleanup)      // Exit test environment (cleanup=tr
       return false;
     }
 
+    // Helper function to create TestTimer class when AccurateTimer is unavailable
+    const createTestTimerClass = function() {
+      globalThis.TestTimer = class {
+        constructor(initialTime = 0) {
+          this.totalTime = Math.max(0, Number(initialTime) || 0);
+          this.startTime = null;
+          this.accumulatedTime = 0;
+          this.isRunning = false;
+        }
+
+        start() {
+          if (this.isRunning) return false;
+          this.startTime = Date.now();
+          this.isRunning = true;
+          return true;
+        }
+
+        stop() {
+          if (this.isRunning && this.startTime) {
+            this.accumulatedTime += Math.floor((Date.now() - this.startTime) / 1000);
+          }
+          this.isRunning = false;
+          this.startTime = null;
+          return this.accumulatedTime;
+        }
+
+        getElapsedTime() {
+          let elapsed = this.accumulatedTime;
+          if (this.isRunning && this.startTime) {
+            elapsed += Math.floor((Date.now() - this.startTime) / 1000);
+          }
+          return elapsed;
+        }
+
+        static formatTime(seconds) {
+          const mins = Math.floor(seconds / 60);
+          const secs = seconds % 60;
+          return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
+        }
+      };
+    };
+
+    // Helper function to test basic timer operations
+    const testBasicTimerOperations = function(verbose) {
+      try {
+        const TimerClass = typeof AccurateTimer !== 'undefined' ? AccurateTimer : globalThis.TestTimer;
+        const timer = new TimerClass(300); // 5 minutes
+
+        const hasBasicProperties = timer.hasOwnProperty ?
+          (Object.prototype.hasOwnProperty.call(timer, 'totalTime') || Object.prototype.hasOwnProperty.call(timer, 'totalTimeInSeconds')) : true;
+
+        if (hasBasicProperties) {
+          if (verbose) console.log('‚úì Timer initialization working');
+          return true;
+        }
+      } catch (initError) {
+        if (verbose) console.log('‚ö†Ô∏è Timer initialization failed:', initError.message);
+      }
+      return false;
+    };
+
+    // Helper function to test start/stop functionality
+    const testStartStopFunctionality = async function(verbose) {
+      try {
+        const TimerClass = typeof AccurateTimer !== 'undefined' ? AccurateTimer : globalThis.TestTimer;
+        const timer = new TimerClass(60); // 1 minute
+
+        const startTime = Date.now();
+        const startResult = timer.start();
+
+        await new Promise(resolve => setTimeout(resolve, 10));
+
+        const stopResult = timer.stop();
+        const endTime = Date.now();
+
+        if (startResult && typeof stopResult === 'number') {
+          if (verbose) console.log('‚úì Start/stop functionality working');
+          return {
+            success: true,
+            testResults: {
+              started: startResult,
+              elapsedTime: stopResult,
+              actualDuration: endTime - startTime
+            }
+          };
+        }
+      } catch (startStopError) {
+        if (verbose) console.log('‚ö†Ô∏è Start/stop test failed:', startStopError.message);
+      }
+      return { success: false, testResults: {} };
+    };
+
+    // Helper function to run performance test
+    const runTimerPerformanceTest = function(verbose) {
+      try {
+        const TimerClass = typeof AccurateTimer !== 'undefined' ? AccurateTimer : globalThis.TestTimer;
+        const perfStart = performance.now();
+
+        const timers = [];
+        for (let i = 0; i < 10; i++) {
+          const timer = new TimerClass(30);
+          timer.start();
+          timers.push(timer);
+        }
+
+        const elapsedTimes = timers.map(t => t.getElapsedTime());
+        timers.forEach(t => t.stop());
+
+        const perfEnd = performance.now();
+        const perfDuration = perfEnd - perfStart;
+
+        if (perfDuration < 50 && elapsedTimes.length === 10) {
+          if (verbose) console.log(`‚úì Performance test passed (${perfDuration.toFixed(2)}ms)`);
+          return true;
+        }
+      } catch (perfError) {
+        if (verbose) console.log('‚ö†Ô∏è Performance test failed:', perfError.message);
+      }
+      return false;
+    };
+
+    // Helper function to generate test summary
+    const generateTimerTestSummary = function(results) {
+      if (results.success) {
+        const accuracyInfo = results.timingAccuracy ?
+          ` Timing accuracy: ${results.timingAccuracy.differenceMs}ms variance.` : '';
+        const performanceInfo = results.performanceTestPassed ? ' Performance ‚úì.' : '';
+        return `AccurateTimer working: class available ‚úì, start/stop ‚úì, pause/resume ‚úì, calculations ‚úì.${accuracyInfo}${performanceInfo}`;
+      } else {
+        const issues = [];
+        if (!results.timerClassAvailable) issues.push('timer class missing');
+        if (!results.basicOperationsWorking) issues.push('basic operations failed');
+        if (!results.startStopFunctional) issues.push('start/stop failed');
+        if (!results.pauseResumeFunctional) issues.push('pause/resume failed');
+        if (!results.timeCalculationAccurate) issues.push('timing inaccurate');
+        return `AccurateTimer issues: ${issues.join(', ')}`;
+      }
+    };
+
     globalThis.testAccurateTimer = async function(options = {}) {
       const { verbose = false } = options;
       if (verbose) console.log('‚è±Ô∏è Testing AccurateTimer reliability...');
@@ -600,91 +739,19 @@ console.log('  - exitTestMode(cleanup)      // Exit test environment (cleanup=tr
           results.timerClassAvailable = true;
           if (verbose) console.log('‚úì AccurateTimer class available');
         } else {
-          // Create a simple timer class for testing if not available
           if (verbose) console.log('‚ö†Ô∏è AccurateTimer not available, creating test timer');
-
-          globalThis.TestTimer = class {
-            constructor(initialTime = 0) {
-              this.totalTime = Math.max(0, Number(initialTime) || 0);
-              this.startTime = null;
-              this.accumulatedTime = 0;
-              this.isRunning = false;
-            }
-
-            start() {
-              if (this.isRunning) return false;
-              this.startTime = Date.now();
-              this.isRunning = true;
-              return true;
-            }
-
-            stop() {
-              if (this.isRunning && this.startTime) {
-                this.accumulatedTime += Math.floor((Date.now() - this.startTime) / 1000);
-              }
-              this.isRunning = false;
-              this.startTime = null;
-              return this.accumulatedTime;
-            }
-
-            getElapsedTime() {
-              let elapsed = this.accumulatedTime;
-              if (this.isRunning && this.startTime) {
-                elapsed += Math.floor((Date.now() - this.startTime) / 1000);
-              }
-              return elapsed;
-            }
-
-            static formatTime(seconds) {
-              const mins = Math.floor(seconds / 60);
-              const secs = seconds % 60;
-              return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
-            }
-          };
-
+          createTestTimerClass();
           results.timerClassAvailable = true;
         }
 
         // 2. Test basic timer operations
-        try {
-          const TimerClass = typeof AccurateTimer !== 'undefined' ? AccurateTimer : globalThis.TestTimer;
-          const timer = new TimerClass(300); // 5 minutes
-
-          const hasBasicProperties = timer.hasOwnProperty ?
-            (Object.prototype.hasOwnProperty.call(timer, 'totalTime') || Object.prototype.hasOwnProperty.call(timer, 'totalTimeInSeconds')) : true;
-
-          if (hasBasicProperties) {
-            results.basicOperationsWorking = true;
-            if (verbose) console.log('‚úì Timer initialization working');
-          }
-        } catch (initError) {
-          if (verbose) console.log('‚ö†Ô∏è Timer initialization failed:', initError.message);
-        }
+        results.basicOperationsWorking = testBasicTimerOperations(verbose);
 
         // 3. Test start/stop functionality
-        try {
-          const TimerClass = typeof AccurateTimer !== 'undefined' ? AccurateTimer : globalThis.TestTimer;
-          const timer = new TimerClass(60); // 1 minute
-
-          const startTime = Date.now();
-          const startResult = timer.start();
-
-          await new Promise(resolve => setTimeout(resolve, 10));
-
-          const stopResult = timer.stop();
-          const endTime = Date.now();
-
-          if (startResult && typeof stopResult === 'number') {
-            results.startStopFunctional = true;
-            results.testResults.startStop = {
-              started: startResult,
-              elapsedTime: stopResult,
-              actualDuration: endTime - startTime
-            };
-            if (verbose) console.log('‚úì Start/stop functionality working');
-          }
-        } catch (startStopError) {
-          if (verbose) console.log('‚ö†Ô∏è Start/stop test failed:', startStopError.message);
+        const startStopResult = await testStartStopFunctionality(verbose);
+        results.startStopFunctional = startStopResult.success;
+        if (startStopResult.success) {
+          results.testResults.startStop = startStopResult.testResults;
         }
 
         // 4. Test pause/resume (if available)
@@ -730,30 +797,7 @@ console.log('  - exitTestMode(cleanup)      // Exit test environment (cleanup=tr
         }
 
         // 7. Performance test
-        try {
-          const TimerClass = typeof AccurateTimer !== 'undefined' ? AccurateTimer : globalThis.TestTimer;
-          const perfStart = performance.now();
-
-          const timers = [];
-          for (let i = 0; i < 10; i++) {
-            const timer = new TimerClass(30);
-            timer.start();
-            timers.push(timer);
-          }
-
-          const elapsedTimes = timers.map(t => t.getElapsedTime());
-          timers.forEach(t => t.stop());
-
-          const perfEnd = performance.now();
-          const perfDuration = perfEnd - perfStart;
-
-          if (perfDuration < 50 && elapsedTimes.length === 10) {
-            results.performanceTestPassed = true;
-            if (verbose) console.log(`‚úì Performance test passed (${perfDuration.toFixed(2)}ms)`);
-          }
-        } catch (perfError) {
-          if (verbose) console.log('‚ö†Ô∏è Performance test failed:', perfError.message);
-        }
+        results.performanceTestPassed = runTimerPerformanceTest(verbose);
 
         // 8. Overall success assessment
         results.success = results.timerClassAvailable &&
@@ -763,20 +807,7 @@ console.log('  - exitTestMode(cleanup)      // Exit test environment (cleanup=tr
                          (results.timeCalculationAccurate || results.performanceTestPassed);
 
         // 9. Generate summary
-        if (results.success) {
-          const accuracyInfo = results.timingAccuracy ?
-            ` Timing accuracy: ${results.timingAccuracy.differenceMs}ms variance.` : '';
-          const performanceInfo = results.performanceTestPassed ? ' Performance ‚úì.' : '';
-          results.summary = `AccurateTimer working: class available ‚úì, start/stop ‚úì, pause/resume ‚úì, calculations ‚úì.${accuracyInfo}${performanceInfo}`;
-        } else {
-          const issues = [];
-          if (!results.timerClassAvailable) issues.push('timer class missing');
-          if (!results.basicOperationsWorking) issues.push('basic operations failed');
-          if (!results.startStopFunctional) issues.push('start/stop failed');
-          if (!results.pauseResumeFunctional) issues.push('pause/resume failed');
-          if (!results.timeCalculationAccurate) issues.push('timing inaccurate');
-          results.summary = `AccurateTimer issues: ${issues.join(', ')}`;
-        }
+        results.summary = generateTimerTestSummary(results);
 
         if (verbose) console.log('‚úÖ AccurateTimer test completed');
 
@@ -895,6 +926,108 @@ console.log('  - exitTestMode(cleanup)      // Exit test environment (cleanup=tr
       }
     }
 
+    // Helper: Test and validate interview configurations
+    const testInterviewConfigurations = function(results, verbose) {
+      try {
+        const interviewModes = ['standard', 'interview-like', 'full-interview'];
+
+        if (results.interviewServiceAvailable && InterviewService.INTERVIEW_CONFIGS) {
+          // Test actual configs
+          for (const mode of interviewModes) {
+            const config = InterviewService.getInterviewConfig(mode);
+            validateInterviewModeConfig(mode, config, results);
+          }
+          results.configsValidated = results.interviewModesSupported.length > 0;
+          if (verbose) console.log('‚úì Interview configs validated:', results.interviewModesSupported);
+        } else {
+          // Simulate interview configs
+          results.configsValidated = true;
+          results.interviewModesSupported = interviewModes;
+          results.configData = {
+            'standard': { hints: null, timing: false, sessionLength: null },
+            'interview-like': { hints: 2, timing: true, sessionLength: { min: 3, max: 5 } },
+            'full-interview': { hints: 0, timing: true, sessionLength: { min: 3, max: 4 } }
+          };
+          if (verbose) console.log('‚úì Interview configs simulated');
+        }
+      } catch (configError) {
+        if (verbose) console.log('‚ö†Ô∏è Interview config validation failed:', configError.message);
+      }
+    };
+
+    // Helper: Validate interview session parameters
+    const validateInterviewSessionParameters = function(sessionData, verbose) {
+      try {
+        if (sessionData) {
+          const validSessionTypes = ['standard', 'interview-like', 'full-interview'];
+          const validSessionLength = typeof sessionData.sessionLength === 'number' &&
+                                    sessionData.sessionLength >= 3 &&
+                                    sessionData.sessionLength <= 6;
+
+          const validSessionType = validSessionTypes.includes(sessionData.sessionType);
+          const hasRequiredData = sessionData.hasConfig && sessionData.hasCriteria;
+
+          const parametersValid = validSessionType && validSessionLength && hasRequiredData;
+
+          if (verbose) {
+            console.log('‚úì Session parameters validation:', {
+              sessionType: validSessionType,
+              sessionLength: validSessionLength,
+              hasRequiredData: hasRequiredData
+            });
+          }
+          return parametersValid;
+        }
+      } catch (validationError) {
+        if (verbose) console.log('‚ö†Ô∏è Parameter validation failed:', validationError.message);
+      }
+      return false;
+    };
+
+    // Helper: Validate problem selection criteria
+    const validateProblemSelectionCriteria = function(problemCriteria, verbose) {
+      try {
+        if (problemCriteria) {
+          const hasTags = problemCriteria.allowedTags && Array.isArray(problemCriteria.allowedTags);
+          const hasDifficulty = problemCriteria.difficulty || problemCriteria.difficulties;
+          const hasConstraints = problemCriteria.maxHints !== undefined || problemCriteria.timePressure;
+
+          const criteriaValid = hasTags || hasDifficulty || hasConstraints;
+
+          if (verbose) {
+            console.log('‚úì Problem criteria validation:', {
+              hasTags: !!hasTags,
+              hasDifficulty: !!hasDifficulty,
+              hasConstraints: !!hasConstraints
+            });
+          }
+          return criteriaValid;
+        }
+      } catch (criteriaError) {
+        if (verbose) console.log('‚ö†Ô∏è Criteria validation failed:', criteriaError.message);
+      }
+      return false;
+    };
+
+    // Helper: Generate interview test summary
+    const generateInterviewTestSummary = function(results, parametersValid, modeDifferencesDetected) {
+      if (results.success) {
+        const modesInfo = results.interviewModesSupported.length > 0 ?
+          ` Modes: ${results.interviewModesSupported.join(', ')}.` : '';
+        const sessionInfo = results.sessionData ?
+          ` Session: ${results.sessionData.sessionType} (${results.sessionData.sessionLength} problems).` : '';
+        const simulatedInfo = results.sessionData?.simulated ? ' (simulated)' : '';
+        return `Interview-like sessions working: configs ‚úì, session creation ‚úì, parameters ‚úì.${modesInfo}${sessionInfo}${simulatedInfo}`;
+      } else {
+        const issues = [];
+        if (!results.configsValidated) issues.push('config validation failed');
+        if (!results.sessionCreated) issues.push('session creation failed');
+        if (!parametersValid) issues.push('parameter validation failed');
+        if (!modeDifferencesDetected && results.interviewModesSupported.length <= 1) issues.push('mode differences not detected');
+        return `Interview-like sessions issues: ${issues.join(', ')}`;
+      }
+    };
+
     globalThis.testInterviewLikeSessions = async function(options = {}) {
       const { verbose = false } = options;
       if (verbose) console.log('üéØ Testing interview-like session creation...');
@@ -921,31 +1054,7 @@ console.log('  - exitTestMode(cleanup)      // Exit test environment (cleanup=tr
         }
 
         // 2. Test interview configurations
-        try {
-          const interviewModes = ['standard', 'interview-like', 'full-interview'];
-
-          if (results.interviewServiceAvailable && InterviewService.INTERVIEW_CONFIGS) {
-            // Test actual configs
-            for (const mode of interviewModes) {
-              const config = InterviewService.getInterviewConfig(mode);
-              validateInterviewModeConfig(mode, config, results);
-            }
-            results.configsValidated = results.interviewModesSupported.length > 0;
-            if (verbose) console.log('‚úì Interview configs validated:', results.interviewModesSupported);
-          } else {
-            // Simulate interview configs
-            results.configsValidated = true;
-            results.interviewModesSupported = interviewModes;
-            results.configData = {
-              'standard': { hints: null, timing: false, sessionLength: null },
-              'interview-like': { hints: 2, timing: true, sessionLength: { min: 3, max: 5 } },
-              'full-interview': { hints: 0, timing: true, sessionLength: { min: 3, max: 4 } }
-            };
-            if (verbose) console.log('‚úì Interview configs simulated');
-          }
-        } catch (configError) {
-          if (verbose) console.log('‚ö†Ô∏è Interview config validation failed:', configError.message);
-        }
+        testInterviewConfigurations(results, verbose);
 
         // 3. Test interview session creation
         try {
@@ -955,30 +1064,7 @@ console.log('  - exitTestMode(cleanup)      // Exit test environment (cleanup=tr
         }
 
         // 4. Test interview session parameters validation
-        let parametersValid = false;
-        try {
-          if (results.sessionData) {
-            const validSessionTypes = ['standard', 'interview-like', 'full-interview'];
-            const validSessionLength = typeof results.sessionData.sessionLength === 'number' &&
-                                      results.sessionData.sessionLength >= 3 &&
-                                      results.sessionData.sessionLength <= 6;
-
-            const validSessionType = validSessionTypes.includes(results.sessionData.sessionType);
-            const hasRequiredData = results.sessionData.hasConfig && results.sessionData.hasCriteria;
-
-            parametersValid = validSessionType && validSessionLength && hasRequiredData;
-
-            if (verbose) {
-              console.log('‚úì Session parameters validation:', {
-                sessionType: validSessionType,
-                sessionLength: validSessionLength,
-                hasRequiredData: hasRequiredData
-              });
-            }
-          }
-        } catch (validationError) {
-          if (verbose) console.log('‚ö†Ô∏è Parameter validation failed:', validationError.message);
-        }
+        const parametersValid = validateInterviewSessionParameters(results.sessionData, verbose);
 
         // 5. Test interview mode differences
         let modeDifferencesDetected = false;
@@ -996,26 +1082,7 @@ console.log('  - exitTestMode(cleanup)      // Exit test environment (cleanup=tr
         }
 
         // 6. Test problem selection criteria
-        let _criteriaValid = false;
-        try {
-          if (results.problemCriteria) {
-            const hasTags = results.problemCriteria.allowedTags && Array.isArray(results.problemCriteria.allowedTags);
-            const hasDifficulty = results.problemCriteria.difficulty || results.problemCriteria.difficulties;
-            const hasConstraints = results.problemCriteria.maxHints !== undefined || results.problemCriteria.timePressure;
-
-            _criteriaValid = hasTags || hasDifficulty || hasConstraints;
-
-            if (verbose) {
-              console.log('‚úì Problem criteria validation:', {
-                hasTags: !!hasTags,
-                hasDifficulty: !!hasDifficulty,
-                hasConstraints: !!hasConstraints
-              });
-            }
-          }
-        } catch (criteriaError) {
-          if (verbose) console.log('‚ö†Ô∏è Criteria validation failed:', criteriaError.message);
-        }
+        const _criteriaValid = validateProblemSelectionCriteria(results.problemCriteria, verbose);
 
         // 7. Overall success assessment
         results.success = results.configsValidated &&
@@ -1024,21 +1091,7 @@ console.log('  - exitTestMode(cleanup)      // Exit test environment (cleanup=tr
                          (modeDifferencesDetected || results.interviewModesSupported.length > 1);
 
         // 8. Generate summary
-        if (results.success) {
-          const modesInfo = results.interviewModesSupported.length > 0 ?
-            ` Modes: ${results.interviewModesSupported.join(', ')}.` : '';
-          const sessionInfo = results.sessionData ?
-            ` Session: ${results.sessionData.sessionType} (${results.sessionData.sessionLength} problems).` : '';
-          const simulatedInfo = results.sessionData?.simulated ? ' (simulated)' : '';
-          results.summary = `Interview-like sessions working: configs ‚úì, session creation ‚úì, parameters ‚úì.${modesInfo}${sessionInfo}${simulatedInfo}`;
-        } else {
-          const issues = [];
-          if (!results.configsValidated) issues.push('config validation failed');
-          if (!results.sessionCreated) issues.push('session creation failed');
-          if (!parametersValid) issues.push('parameter validation failed');
-          if (!modeDifferencesDetected && results.interviewModesSupported.length <= 1) issues.push('mode differences not detected');
-          results.summary = `Interview-like sessions issues: ${issues.join(', ')}`;
-        }
+        results.summary = generateInterviewTestSummary(results, parametersValid, modeDifferencesDetected);
 
         if (verbose) console.log('‚úÖ Interview-like sessions test completed');
         // Return boolean for backward compatibility when not verbose
