import React, { useState, useEffect, useCallback } from "react";
import logger, { debug } from "../../../shared/utils/logger.js";
import {
  Card,
  Text,
  Group,
  Badge,
  Button,
  Loader,
  Alert,
  Tooltip,
  Stack,
  Title,
} from "@mantine/core";
import CustomMultiSelect from "../shared/CustomMultiSelect";
import {
  IconTarget,
  IconRefresh,
  IconInfoCircle,
  IconTrophy,
} from "@tabler/icons-react";
// Note: Using Chrome messaging for all service calls to comply with extension architecture
// All database access goes through background script

export function FocusAreasSelector() {
  const [availableTags, setAvailableTags] = useState([]);
  const [selectedFocusAreas, setSelectedFocusAreas] = useState([]);
  const [currentTier, setCurrentTier] = useState("");
  const [masteredTags, setMasteredTags] = useState([]);
  const [masteryData, setMasteryData] = useState([]);
  const [focusAvailability, setFocusAvailability] = useState({
    access: { core: "confirmed", fundamental: "none", advanced: "none" },
    caps: { core: Infinity, fundamental: 3, advanced: 3 },
    tags: [],
    starterCore: [],
    currentTier: "Unknown",
    systemSelectedTags: [],
    userOverrideTags: [],
    activeSessionTags: []
  });
  const [showCustomMode, setShowCustomMode] = useState(false);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState(null);
  const [hasChanges, setHasChanges] = useState(false);

  // Log when focusAvailability state changes
  useEffect(() => {
    debug("ðŸ” LIFECYCLE: focusAvailability state changed", { focusAvailability });
    debug("ðŸ” LIFECYCLE: focusAvailability starterCore after change", { starterCore: focusAvailability?.starterCore });
  }, [focusAvailability]);

  const loadData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      // Get available tags, mastery data, and current tier
      const [availableTagsResponse, masteryResponse, currentTierResponse, focusAvailabilityResponse, currentFocusResponse] =
        await Promise.all([
          chrome.runtime.sendMessage({ type: "getAvailableTags" }),
          chrome.runtime.sendMessage({ type: "getTagMasteryData" }),
          chrome.runtime.sendMessage({ type: "getCurrentTier" }),
          chrome.runtime.sendMessage({ type: "getFocusAvailability" }),
          chrome.runtime.sendMessage({ type: "getCurrentFocusAreas" }),
        ]);

      debug("ðŸ” FocusAreasSelector: loadData responses received", {
        availableTagsResponse,
        masteryResponse,
        currentTierResponse,
        focusAvailabilityResponse,
        currentFocusResponse,
      });

      if (availableTagsResponse.success && Array.isArray(availableTagsResponse.data)) {
        setAvailableTags(availableTagsResponse.data);
      } else {
        logger.warn("Failed to load available tags", availableTagsResponse);
      }

      if (masteryResponse.success && Array.isArray(masteryResponse.data)) {
        setMasteryData(masteryResponse.data);
        const mastered = masteryResponse.data.filter(tag => tag.level >= 3).map(tag => tag.tag);
        setMasteredTags(mastered);
      } else {
        logger.warn("Failed to load mastery data", masteryResponse);
      }

      if (currentTierResponse.success && currentTierResponse.data) {
        setCurrentTier(currentTierResponse.data);
      } else {
        logger.warn("Failed to load current tier", currentTierResponse);
      }

      if (focusAvailabilityResponse.success && focusAvailabilityResponse.data) {
        debug("ðŸ” FocusAreasSelector: Setting focusAvailability from response", { data: focusAvailabilityResponse.data });
        setFocusAvailability(focusAvailabilityResponse.data);
        debug("ðŸ” FocusAreasSelector: focusAvailability.starterCore from response", { starterCore: focusAvailabilityResponse.data.starterCore });
      } else {
        logger.warn("Failed to load focus availability", focusAvailabilityResponse);
      }

      if (currentFocusResponse.success && Array.isArray(currentFocusResponse.data)) {
        setSelectedFocusAreas(currentFocusResponse.data);
      } else {
        logger.warn("Failed to load current focus areas", currentFocusResponse);
      }
    } catch (error) {
      logger.error("Failed to load data", error);
      setError("Failed to load focus areas data");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadData();
  }, [loadData]);

  // Track changes in selected focus areas
  useEffect(() => {
    // Only mark as changed if not loading and we have initial data
    if (!loading && (selectedFocusAreas.length > 0 || availableTags.length > 0)) {
      setHasChanges(true);
    }
  }, [selectedFocusAreas, loading, availableTags]);

  const handleFocusAreasChange = (values) => {
    debug("ðŸ” FocusAreasSelector: handleFocusAreasChange", { values });
    setSelectedFocusAreas(values);
    setHasChanges(true);
  };

  const handleSave = async () => {
    try {
      setSaving(true);
      setError(null);

      const response = await chrome.runtime.sendMessage({
        type: "setFocusAreas",
        focusAreas: selectedFocusAreas,
      });

      if (response.success) {
        setHasChanges(false);
        // Don't reload data immediately after save to avoid flickering
      } else {
        setError("Failed to save focus areas");
        logger.error("Failed to save focus areas", response);
      }
    } catch (error) {
      setError("Failed to save focus areas");
      logger.error("Failed to save focus areas", error);
    } finally {
      setSaving(false);
    }
  };

  const handleReset = async () => {
    try {
      setSaving(true);
      setError(null);

      // Reset to system-selected tags (intelligent defaults)
      const response = await chrome.runtime.sendMessage({
        type: "resetFocusAreasToDefaults",
      });

      if (response.success) {
        // Reload data to get the reset values
        await loadData();
        setHasChanges(false);
      } else {
        setError("Failed to reset focus areas");
        logger.error("Failed to reset focus areas", response);
      }
    } catch (error) {
      setError("Failed to reset focus areas");
      logger.error("Failed to reset focus areas", error);
    } finally {
      setSaving(false);
    }
  };

  const getTagMasteryProgress = (tagName) => {
    const tagData = masteryData.find((tag) => tag.tag === tagName);
    if (!tagData || tagData.totalAttempts === 0) return 0;
    return Math.round((tagData.successfulAttempts / tagData.totalAttempts) * 100);
  };

  const getTagOptions = () => {
    try {
      debug("ðŸ” getTagOptions called", { focusAvailability });
      
      // ALWAYS return a safe object, even if everything fails
      const _safeReturn = { selectableOptions: [], previewTags: [] };
      
      if (!focusAvailability || !focusAvailability.tags || !Array.isArray(focusAvailability.tags)) {
        // Fallback to original logic
        debug("ðŸ” FocusAreasSelector: No focusAvailability tags, using fallback");
        
        // Ensure availableTags and masteredTags are arrays
        const safeAvailableTags = Array.isArray(availableTags) ? availableTags : [];
        const safeMasteredTags = Array.isArray(masteredTags) ? masteredTags : [];
        
        const filtered = safeAvailableTags.filter((tag) => !safeMasteredTags.includes(tag));
        const mapped = filtered.map((tag) => ({
          value: tag,
          label: tag.charAt(0).toUpperCase() + tag.slice(1).replace(/[-_]/g, " "),
        }));
        
        debug("ðŸ” FocusAreasSelector: Using fallback logic", { selectableOptions: mapped });
        return { selectableOptions: Array.isArray(mapped) ? mapped : [], previewTags: [] };
      }

      // Using new focusAvailability system
      debug("ðŸ” FocusAreasSelector: Using focusAvailability tags", { tags: focusAvailability.tags });
      
      // Process available tags from focusAvailability
      const selectableOptions = [];
      const previewTags = [];
      
      if (Array.isArray(focusAvailability.tags)) {
        focusAvailability.tags.forEach((tagInfo) => {
          const tagName = typeof tagInfo === 'string' ? tagInfo : tagInfo?.tag;
          if (!tagName) return;
          
          const isSelectable = typeof tagInfo === 'string' || (tagInfo?.reason !== 'preview-locked');
          const progress = getTagMasteryProgress(tagName);
          
          const option = {
            value: tagName,
            label: tagName.charAt(0).toUpperCase() + tagName.slice(1).replace(/[-_]/g, " "),
            reason: typeof tagInfo === 'object' ? tagInfo.reason : 'available',
            progress,
          };
          
          if (isSelectable) {
            selectableOptions.push(option);
          } else {
            previewTags.push(option);
          }
        });
      }
      
      debug("ðŸ” FocusAreasSelector: Processed tag options", { selectableOptions, previewTags });
      return { selectableOptions: Array.isArray(selectableOptions) ? selectableOptions : [], previewTags: Array.isArray(previewTags) ? previewTags : [] };
    } catch (error) {
      logger.error("Error in getTagOptions", error);
      return { selectableOptions: [], previewTags: [] };
    }
  };

  const renderSelectedTagBadges = () => {
    if (!Array.isArray(selectedFocusAreas) || selectedFocusAreas.length === 0) {
      return (
        <Text size="sm" c="dimmed">
          No focus areas selected
        </Text>
      );
    }

    return (
      <Group gap="xs">
        {selectedFocusAreas.map((tag) => {
          const progress = getTagMasteryProgress(tag);
          return (
            <Tooltip
              key={tag}
              label={`${tag}: ${progress}% mastery`}
              position="top"
            >
              <Badge
                variant="light"
                color={progress >= 70 ? "green" : progress >= 40 ? "blue" : "gray"}
                leftSection={
                  progress >= 70 ? <IconTrophy size={12} /> : null
                }
              >
                {tag.charAt(0).toUpperCase() + tag.slice(1).replace(/[-_]/g, " ")}
              </Badge>
            </Tooltip>
          );
        })}
      </Group>
    );
  };

  if (loading) {
    return (
      <Card shadow="sm" p="lg" radius="md" withBorder>
        <Group justify="center" p="xl">
          <Loader size="md" />
          <Text>Loading focus areas...</Text>
        </Group>
      </Card>
    );
  }

  return (
    <Card shadow="sm" p="lg" radius="md" withBorder>
      <Stack gap="md">
        <Group justify="space-between" align="flex-start">
          <div>
            <Title order={4} mb="xs">
              <IconTarget size={18} style={{ marginRight: 8 }} />
              Focus Areas Configuration
            </Title>
            <Text size="sm" c="dimmed">
              Select the algorithm topics you want to focus on during practice sessions.
            </Text>
          </div>
          <Group gap="xs">
            <Tooltip label="Reset to intelligent defaults" position="left">
              <Button
                variant="light"
                size="xs"
                leftSection={<IconRefresh size={14} />}
                onClick={handleReset}
                loading={saving}
                disabled={!hasChanges}
              >
                Reset
              </Button>
            </Tooltip>
          </Group>
        </Group>

        {error && (
          <Alert
            icon={<IconInfoCircle size={16} />}
            color="red"
            onClose={() => setError(null)}
          >
            {error}
          </Alert>
        )}

        {/* Current Tier Information */}
        {currentTier && (
          <Group gap="xs">
            <Text size="sm" fw={500}>
              Current Tier:
            </Text>
            <Badge variant="filled" color="blue">
              {currentTier}
            </Badge>
          </Group>
        )}

        {/* System Information */}
        {focusAvailability && (
          <Alert icon={<IconInfoCircle size={16} />} color="blue" variant="light">
            <Text size="sm">
              <strong>Access Levels:</strong> Core: {focusAvailability.access?.core || 'unknown'}, 
              Fundamental: {focusAvailability.access?.fundamental || 'unknown'}, 
              Advanced: {focusAvailability.access?.advanced || 'unknown'}
            </Text>
            {focusAvailability.starterCore && Array.isArray(focusAvailability.starterCore) && (
              <Text size="sm" mt="xs">
                <strong>Starter Core Tags:</strong> {focusAvailability.starterCore.join(', ')}
              </Text>
            )}
          </Alert>
        )}

        {/* Focus Areas Selection */}
        <div>
          <Group justify="space-between" mb="xs">
            <Text size="sm" fw={500}>
              Select Focus Areas
            </Text>
            {(() => {
              const { selectableOptions } = getTagOptions();
              const maxTags = focusAvailability.caps?.fundamental || 3;
              return (
                <Text size="xs" c="dimmed">
                  {selectedFocusAreas.length}/{maxTags} selected
                </Text>
              );
            })()}
          </Group>

          <CustomMultiSelect
            label=""
            placeholder="Choose algorithm topics to focus on..."
            data={(() => {
              const { selectableOptions } = getTagOptions();
              return selectableOptions;
            })()}
            value={selectedFocusAreas}
            onChange={handleFocusAreasChange}
            maxValues={focusAvailability.caps?.fundamental || 3}
            clearable={true}
            searchable={true}
            description="Select specific algorithm topics for targeted practice"
          />
        </div>

        {/* Current Selection Display */}
        <div>
          <Text size="sm" fw={500} mb="xs">
            Current Selection
          </Text>
          {renderSelectedTagBadges()}
        </div>

        {/* Preview Tags (locked) */}
        {(() => {
          const { previewTags } = getTagOptions();
          if (!Array.isArray(previewTags) || previewTags.length === 0) return null;
          
          return (
            <div>
              <Text size="sm" fw={500} mb="xs">
                Preview Tags (Locked)
              </Text>
              <Group gap="xs">
                {previewTags.map((tag) => (
                  <Tooltip
                    key={tag.value}
                    label={`${tag.label} - Preview only (locked)`}
                    position="top"
                  >
                    <Badge variant="outline" color="gray">
                      {tag.label}
                    </Badge>
                  </Tooltip>
                ))}
              </Group>
            </div>
          );
        })()}

        {/* System Selected vs User Override Info */}
        {focusAvailability.systemSelectedTags && focusAvailability.systemSelectedTags.length > 0 && (
          <Alert icon={<IconInfoCircle size={16} />} color="cyan" variant="light">
            <Text size="sm">
              <strong>System Recommendations:</strong> {focusAvailability.systemSelectedTags.join(', ')}
            </Text>
            {focusAvailability.userOverrideTags && focusAvailability.userOverrideTags.length > 0 && (
              <Text size="sm" mt="xs">
                <strong>Your Overrides:</strong> {focusAvailability.userOverrideTags.join(', ')}
              </Text>
            )}
          </Alert>
        )}

        {/* Custom Mode Toggle */}
        <Group justify="space-between">
          <div>
            <Text size="sm" fw={500}>
              Advanced Mode
            </Text>
            <Text size="xs" c="dimmed">
              Override system recommendations with custom selections
            </Text>
          </div>
          <Button
            variant={showCustomMode ? "filled" : "light"}
            size="xs"
            onClick={() => setShowCustomMode(!showCustomMode)}
          >
            {showCustomMode ? "Hide" : "Show"} Custom Mode
          </Button>
        </Group>

        {/* Custom Mode Options */}
        {showCustomMode && (
          <Alert icon={<IconInfoCircle size={16} />} color="orange" variant="light">
            <Text size="sm" mb="xs">
              <strong>Custom Mode:</strong> You can manually select focus areas, but the system's intelligent recommendations are usually more effective for learning progression.
            </Text>
            
            {/* Additional custom options could go here */}
            <Group gap="xs" mt="sm">
              <Button
                size="xs"
                variant="subtle"
                onClick={() => {
                  // Set to all available core tags
                  const coreOptions = getTagOptions().selectableOptions.filter(opt => opt.reason === 'core' || opt.reason === 'available');
                  const coreValues = coreOptions.slice(0, focusAvailability.caps?.core || 5).map(opt => opt.value);
                  setSelectedFocusAreas(coreValues);
                  setHasChanges(true);
                }}
              >
                Select Core Tags
              </Button>
              <Button
                size="xs"
                variant="subtle"
                onClick={() => {
                  // Set to system recommendations
                  if (focusAvailability.systemSelectedTags) {
                    setSelectedFocusAreas([...focusAvailability.systemSelectedTags]);
                    setHasChanges(true);
                  }
                }}
              >
                Use System Recommendations
              </Button>
            </Group>
          </Alert>
        )}

        {/* Active Session Tags Info */}
        {focusAvailability.activeSessionTags && focusAvailability.activeSessionTags.length > 0 && (
          <Alert icon={<IconInfoCircle size={16} />} color="green" variant="light">
            <Text size="sm">
              <strong>Currently Active in Session:</strong> {focusAvailability.activeSessionTags.join(', ')}
            </Text>
          </Alert>
        )}

        {/* Save Button */}
        <Group justify="flex-end" mt="md">
          <Button
            onClick={handleSave}
            loading={saving}
            disabled={!hasChanges}
            leftSection={<IconTarget size={16} />}
          >
            Save Focus Areas
          </Button>
        </Group>
      </Stack>
    </Card>
  );
}