[
  {
    "tag": "array",
    "overview": "The foundational data structure for indexed access and sequential processing, appearing in over 1/3 of all problems.",
    "patterns": ["greedy", "dynamic programming", "math", "sorting", "simulation", "hash table"],
    "related": ["hash table", "two pointers", "sorting", "dynamic programming", "greedy", "math"],
    "strategy": "Use index-based traversal and consider multiple pointers for optimization. Prefix sums and sliding windows often eliminate nested loops."
  },
  {
    "tag": "backtracking",
    "overview": "Algorithmic approach that incrementally builds solutions and abandons candidates that cannot lead to valid solutions.",
    "patterns": ["string", "dynamic programming", "recursion", "enumeration", "depth-first search"],
    "related": ["string", "dynamic programming", "recursion", "enumeration", "depth-first search"],
    "strategy": "Use for generating all possible solutions systematically. Implement proper pruning to avoid unnecessary exploration of invalid paths."
  },
  {
    "tag": "binary indexed tree",
    "overview": "Efficient data structure for calculating prefix sums and handling range queries with point updates.",
    "patterns": ["segment tree", "divide and conquer", "array", "dynamic programming"],
    "related": [],
    "strategy": "Use for range sum queries and point updates in O(log n) time. Build using binary representation of indices for efficient traversal."
  },
  {
    "tag": "binary search",
    "overview": "Efficient search algorithm that repeatedly divides sorted search space in half to find target values.",
    "patterns": ["array", "math", "greedy", "sorting"],
    "related": ["array", "sorting", "math"],
    "strategy": "Look for monotonic properties in the search space. Use template: while(left < right) with careful boundary handling to avoid infinite loops."
  },
  {
    "tag": "binary search tree",
    "overview": "Binary tree with ordering property where left subtree values are less than node, which is less than right subtree values.",
    "patterns": ["dynamic programming", "binary tree", "tree", "depth-first search", "recursion"],
    "related": ["binary tree", "tree", "dynamic programming", "depth-first search", "recursion"],
    "strategy": "Leverage BST property for O(log n) operations. Inorder traversal gives sorted sequence for many problems."
  },
  {
    "tag": "binary tree",
    "overview": "Tree data structure where each node has at most two children, referred to as left and right child.",
    "patterns": ["binary search tree", "tree", "dynamic programming", "depth-first search", "recursion"],
    "related": ["binary search tree", "tree", "dynamic programming", "depth-first search", "recursion"],
    "strategy": "Master three traversal orders: inorder, preorder, postorder. Consider level-order traversal for breadth-first problems."
  },
  {
    "tag": "bit manipulation",
    "overview": "Techniques for manipulating individual bits in binary representations to solve problems efficiently.",
    "patterns": ["array", "math", "string", "dynamic programming"],
    "related": ["array", "math", "string", "dynamic programming"],
    "strategy": "Master basic operations: AND, OR, XOR, bit shifts. XOR is particularly useful for finding unique elements and toggling states."
  },
  {
    "tag": "bitmask",
    "overview": "Technique using bit patterns to represent sets of states or subsets efficiently in dynamic programming.",
    "patterns": ["dynamic programming", "backtracking"],
    "related": [],
    "strategy": "Use for subset enumeration and state compression in DP. Each bit represents inclusion/exclusion of an element."
  },
  {
    "tag": "brainteaser",
    "overview": "Logic puzzles and mathematical problems that require creative thinking and pattern recognition.",
    "patterns": ["math", "string", "geometry"],
    "related": ["math", "string"],
    "strategy": "Look for mathematical patterns and edge cases. Often involves modular arithmetic, probability, or logical deduction."
  },
  {
    "tag": "breadth-first search",
    "overview": "Graph traversal algorithm that explores neighbors before moving to next level vertices, guaranteeing shortest paths.",
    "patterns": ["graph", "topological sort", "depth-first search", "matrix"],
    "related": ["graph", "topological sort", "depth-first search", "tree", "binary search tree", "binary tree"],
    "strategy": "Use for shortest path in unweighted graphs and level-order tree traversal. Queue-based implementation is standard."
  },
  {
    "tag": "combinatorics",
    "overview": "Branch of mathematics concerning counting, arrangement, and selection of objects in systematic ways.",
    "patterns": ["dynamic programming", "math"],
    "related": [],
    "strategy": "Use factorial, combination, and permutation formulas. Dynamic programming helps with complex counting problems involving constraints."
  },
  {
    "tag": "counting",
    "overview": "Problems involving frequency analysis, occurrence tracking, and statistical counting operations on data.",
    "patterns": ["array", "string", "hash table", "math", "dynamic programming"],
    "related": ["array", "string", "hash table", "math", "dynamic programming"],
    "strategy": "Use hash maps for frequency counting. Consider prefix sums for range counting queries and sliding window for subarray counts."
  },
  {
    "tag": "data stream",
    "overview": "Problems involving processing continuous streams of data with constraints on memory and time.",
    "patterns": ["design", "hash table", "queue", "simulation"],
    "related": ["design", "hash table", "queue"],
    "strategy": "Use sliding window techniques and efficient data structures. Consider space-time tradeoffs for online algorithms."
  },
  {
    "tag": "database",
    "overview": "Problems involving database operations, query optimization, and data management systems.",
    "patterns": ["design", "sorting", "simulation"],
    "related": ["design", "sorting"],
    "strategy": "Focus on efficient query processing and indexing strategies. Consider join operations and data normalization principles."
  },
  {
    "tag": "depth-first search",
    "overview": "Graph traversal algorithm that explores as far as possible along each branch before backtracking.",
    "patterns": ["backtracking", "binary search tree", "tree", "dynamic programming", "graph", "topological sort"],
    "related": ["backtracking", "binary search tree", "tree", "dynamic programming", "graph"],
    "strategy": "Use for path finding, cycle detection, and topological sorting. Mark visited nodes to avoid infinite loops in cyclic graphs."
  },
  {
    "tag": "design",
    "overview": "Problems requiring the implementation of data structures or systems with specific operational requirements.",
    "patterns": ["hash table", "simulation", "data stream", "queue", "tree", "binary search tree"],
    "related": ["hash table", "simulation", "tree", "binary search tree", "stack"],
    "strategy": "Focus on API design and efficient data structure choice. Consider time-space complexity tradeoffs for different operations."
  },
  {
    "tag": "divide and conquer",
    "overview": "Algorithm design paradigm that recursively breaks problems into smaller independent subproblems.",
    "patterns": ["array", "dynamic programming", "recursion"],
    "related": [],
    "strategy": "Divide problem into independent subproblems, solve recursively, then combine results. Often yields O(n log n) time complexity."
  },
  {
    "tag": "doubly-linked list",
    "overview": "Linked list variant where each node has pointers to both next and previous nodes for bidirectional traversal.",
    "patterns": ["dynamic programming", "backtracking", "recursion"],
    "related": ["dynamic programming", "backtracking", "linked list"],
    "strategy": "Leverage bidirectional pointers for efficient insertion and deletion. Useful for implementing LRU caches and deques."
  },
  {
    "tag": "dynamic programming",
    "overview": "Problem-solving technique that breaks complex problems into overlapping subproblems with optimal substructure.",
    "patterns": ["string", "backtracking", "recursion", "array", "greedy", "math"],
    "related": ["string", "backtracking", "recursion", "array", "greedy", "math"],
    "strategy": "Identify overlapping subproblems and optimal substructure. Start with recursive solution, then add memoization or build bottom-up table."
  },
  {
    "tag": "enumeration",
    "overview": "Systematic counting or listing of all possible cases or solutions to explore the complete solution space.",
    "patterns": ["string", "math", "array", "backtracking", "dynamic programming"],
    "related": ["string", "math", "array", "backtracking", "dynamic programming"],
    "strategy": "Generate all valid cases systematically. Use backtracking for complex constraints and pruning for efficiency."
  },
  {
    "tag": "eulerian circuit",
    "overview": "Path in graph that visits every edge exactly once, fundamental concept in graph theory and traversal problems.",
    "patterns": ["strongly connected component", "graph", "topological sort", "breadth-first search"],
    "related": [],
    "strategy": "Check that all vertices have even degree for undirected graphs. Use Hierholzer's algorithm for circuit construction."
  },
  {
    "tag": "game theory",
    "overview": "Mathematical framework for analyzing strategic decision-making between rational players in competitive scenarios.",
    "patterns": ["dynamic programming", "simulation"],
    "related": ["dynamic programming", "simulation"],
    "strategy": "Analyze winning and losing positions using minimax algorithm. Consider optimal play from both players' perspectives."
  },
  {
    "tag": "geometry",
    "overview": "Problems involving geometric shapes, coordinates, distances, and spatial relationships in 2D or 3D space.",
    "patterns": ["math", "simulation", "sorting"],
    "related": ["math", "simulation"],
    "strategy": "Use coordinate geometry formulas for distance and area calculations. Consider precision issues with floating-point arithmetic."
  },
  {
    "tag": "graph",
    "overview": "Data structure representing relationships between entities through vertices connected by edges.",
    "patterns": ["topological sort", "breadth-first search", "depth-first search", "eulerian circuit", "strongly connected component"],
    "related": ["topological sort", "breadth-first search", "depth-first search"],
    "strategy": "Choose DFS for path-related problems, BFS for shortest paths. Consider adjacency list vs matrix representation based on density."
  },
  {
    "tag": "greedy",
    "overview": "Algorithm paradigm that makes locally optimal choices at each step to find global optimum solution.",
    "patterns": ["array", "dynamic programming", "sorting", "string", "math"],
    "related": ["array", "dynamic programming", "sorting", "string", "math"],
    "strategy": "Identify problems with optimal substructure but no overlapping subproblems. Sort data first when order matters for greedy choice."
  },
  {
    "tag": "hash function",
    "overview": "Function that maps data of arbitrary size to fixed-size values, used in hashing and string algorithms.",
    "patterns": ["string", "sliding window"],
    "related": [],
    "strategy": "Use for fast string comparison and pattern matching. Rolling hash enables efficient sliding window string operations."
  },
  {
    "tag": "hash table",
    "overview": "Data structure providing O(1) average-case lookup, insertion, and deletion operations using key-value mapping.",
    "patterns": ["array", "string", "counting", "sliding window"],
    "related": ["array", "string", "counting", "two pointers"],
    "strategy": "Use for frequency counting, fast lookups, and eliminating nested loops. Consider space-time tradeoffs and collision handling."
  },
  {
    "tag": "heap (priority queue)",
    "overview": "Complete binary tree with heap property, enabling efficient priority queue operations and selection algorithms.",
    "patterns": ["sorting", "greedy", "array"],
    "related": ["sorting", "greedy", "array"],
    "strategy": "Use for top-k problems and maintaining extremes efficiently. Min-heap for smallest elements, max-heap for largest elements."
  },
  {
    "tag": "interactive",
    "overview": "Problems where solution must interact with hidden system through queries, with limited query budget.",
    "patterns": ["binary search", "graph"],
    "related": [],
    "strategy": "Minimize number of queries through binary search or strategic probing. Analyze information gained from each query."
  },
  {
    "tag": "iterator",
    "overview": "Design pattern for traversing collections without exposing underlying representation, enabling clean iteration.",
    "patterns": ["binary search tree", "array", "design"],
    "related": ["binary search tree", "array", "design"],
    "strategy": "Implement stateful traversal with clear separation of concerns. Handle edge cases like empty collections and concurrent modification."
  },
  {
    "tag": "line sweep",
    "overview": "Algorithmic technique that processes geometric objects by sweeping a line across the plane systematically.",
    "patterns": ["segment tree", "array"],
    "related": [],
    "strategy": "Sort events by coordinate and process in order. Use data structures to maintain active objects during sweep."
  },
  {
    "tag": "linked list",
    "overview": "Linear data structure where elements are stored in nodes containing data and pointer to next node.",
    "patterns": ["two pointers", "dynamic programming", "backtracking", "recursion"],
    "related": ["two pointers", "dynamic programming", "backtracking", "recursion"],
    "strategy": "Use two pointers for cycle detection and finding middle. Dummy nodes simplify edge case handling in modifications."
  },
  {
    "tag": "math",
    "overview": "Problems requiring mathematical concepts, formulas, number theory, and computational mathematics.",
    "patterns": ["array", "dynamic programming", "string", "greedy", "simulation", "counting"],
    "related": ["array", "dynamic programming", "string", "greedy", "simulation", "counting"],
    "strategy": "Look for mathematical patterns and closed-form solutions. Consider modular arithmetic for large numbers and overflow prevention."
  },
  {
    "tag": "matrix",
    "overview": "Two-dimensional array structure useful for grid-based problems and spatial relationship modeling.",
    "patterns": ["array", "simulation", "dynamic programming", "depth-first search", "breadth-first search"],
    "related": ["array", "simulation", "dynamic programming", "depth-first search", "backtracking"],
    "strategy": "Consider direction vectors for neighbor access. Use DFS/BFS for connected component problems and path finding."
  },
  {
    "tag": "memoization",
    "overview": "Optimization technique storing results of expensive function calls to avoid recomputation in recursive solutions.",
    "patterns": ["dynamic programming", "recursion"],
    "related": [],
    "strategy": "Add cache to recursive solutions with overlapping subproblems. Use dictionary or array for storage based on state space."
  },
  {
    "tag": "merge sort",
    "overview": "Divide-and-conquer sorting algorithm with guaranteed O(n log n) time complexity and stable sorting property.",
    "patterns": ["quickselect", "sorting"],
    "related": [],
    "strategy": "Use for stable sorting and when worst-case O(n log n) is required. Excellent for external sorting of large datasets."
  },
  {
    "tag": "minimum spanning tree",
    "overview": "Subset of edges in weighted graph that connects all vertices with minimum total weight, no cycles.",
    "patterns": ["graph", "topological sort", "union find"],
    "related": ["graph", "topological sort"],
    "strategy": "Use Kruskal's algorithm with union-find or Prim's algorithm with priority queue for efficient MST construction."
  },
  {
    "tag": "monotonic stack",
    "overview": "Stack variant that maintains elements in monotonic order, useful for finding next greater/smaller elements.",
    "patterns": ["array", "stack"],
    "related": [],
    "strategy": "Maintain increasing or decreasing order by popping elements. Useful for histogram problems and temperature-like queries."
  },
  {
    "tag": "number theory",
    "overview": "Branch of mathematics studying properties and relationships of integers, primes, and modular arithmetic.",
    "patterns": ["math"],
    "related": ["math"],
    "strategy": "Master GCD, LCM, and modular arithmetic operations. Use sieve algorithms for prime-related problems efficiently."
  },
  {
    "tag": "ordered set",
    "overview": "Data structure maintaining elements in sorted order with efficient insertion, deletion, and range queries.",
    "patterns": ["design", "segment tree"],
    "related": [],
    "strategy": "Use balanced BST or segment tree for order statistics. Consider treap or skip list for implementation alternatives."
  },
  {
    "tag": "prefix sum",
    "overview": "Preprocessing technique storing cumulative sums to answer range sum queries efficiently in constant time.",
    "patterns": ["array", "matrix", "sliding window", "math"],
    "related": ["array", "matrix", "sliding window", "math"],
    "strategy": "Build prefix array where prefix[i] = sum from 0 to i. Range sum = prefix[j] - prefix[i-1] for range [i,j]."
  },
  {
    "tag": "probability and statistics",
    "overview": "Mathematical concepts dealing with uncertainty, randomness, statistical analysis, and probabilistic reasoning.",
    "patterns": ["math", "dynamic programming"],
    "related": [],
    "strategy": "Apply probability rules and expected value calculations. Use combinatorial counting and Bayes' theorem for complex scenarios."
  },
  {
    "tag": "queue",
    "overview": "First-In-First-Out (FIFO) data structure supporting enqueue and dequeue operations for sequential processing.",
    "patterns": ["simulation", "design", "data stream"],
    "related": ["simulation", "design", "stack"],
    "strategy": "Use for level-order traversals and problems requiring processing in arrival order. Consider circular queue for efficiency."
  },
  {
    "tag": "quickselect",
    "overview": "Selection algorithm for finding k-th smallest element with average O(n) time complexity using partitioning.",
    "patterns": ["sorting", "merge sort"],
    "related": [],
    "strategy": "Use partitioning logic from quicksort but recurse only on relevant side. Randomization improves average case performance."
  },
  {
    "tag": "randomized",
    "overview": "Algorithms that use random choices during execution to achieve better average-case performance or simplicity.",
    "patterns": ["simulation", "design"],
    "related": ["simulation", "design"],
    "strategy": "Use randomization for load balancing and average-case optimization. Consider Monte Carlo methods for approximation problems."
  },
  {
    "tag": "recursion",
    "overview": "Problem-solving approach where function calls itself with smaller subproblems until reaching base cases.",
    "patterns": ["dynamic programming", "backtracking", "binary search tree", "tree", "binary tree"],
    "related": ["dynamic programming", "backtracking", "binary search tree", "tree", "binary tree"],
    "strategy": "Define base cases clearly and ensure progress toward base case. Consider memoization for overlapping subproblems."
  },
  {
    "tag": "rolling hash",
    "overview": "Hash function that efficiently updates hash value as window slides, enabling fast string pattern matching.",
    "patterns": ["string", "string matching"],
    "related": [],
    "strategy": "Use for substring search and comparison in sliding window. Polynomial rolling hash with large prime modulus prevents collisions."
  },
  {
    "tag": "segment tree",
    "overview": "Binary tree data structure for answering range queries and updates efficiently with logarithmic complexity.",
    "patterns": ["array", "binary indexed tree"],
    "related": [],
    "strategy": "Build tree bottom-up for range queries in O(log n). Use lazy propagation for efficient range updates."
  },
  {
    "tag": "shortest path",
    "overview": "Finding minimum cost path between vertices in weighted graphs using various algorithmic approaches.",
    "patterns": ["graph", "topological sort", "breadth-first search"],
    "related": ["graph", "topological sort", "breadth-first search"],
    "strategy": "Use BFS for unweighted graphs, Dijkstra for non-negative weights. Consider Floyd-Warshall for all-pairs shortest paths."
  },
  {
    "tag": "simulation",
    "overview": "Direct implementation of problem requirements by mimicking the described process step-by-step systematically.",
    "patterns": ["array", "string", "matrix", "math", "graph", "topological sort"],
    "related": ["array", "string", "matrix", "math", "stack"],
    "strategy": "Break down complex requirements into simple steps. Handle edge cases carefully and validate intermediate states."
  },
  {
    "tag": "sliding window",
    "overview": "Technique maintaining a window of elements and sliding it across data structure to solve subarray problems.",
    "patterns": ["string", "array", "hash table", "two pointers"],
    "related": ["string", "array", "hash table", "two pointers"],
    "strategy": "Identify subarray/substring problems with constraints. Expand window when possible, contract when constraint is violated."
  },
  {
    "tag": "sorting",
    "overview": "Algorithms for arranging elements in specific order, often serving as preprocessing step for other algorithms.",
    "patterns": ["array", "greedy", "two pointers", "string", "math"],
    "related": ["array", "greedy", "two pointers", "string", "hash table"],
    "strategy": "Consider whether order matters for the solution approach. Custom comparators enable complex sorting criteria and logic."
  },
  {
    "tag": "stack",
    "overview": "Last-In-First-Out (LIFO) data structure supporting push, pop, and peek operations for sequential processing.",
    "patterns": ["string", "simulation", "array", "dynamic programming"],
    "related": ["string", "simulation", "array", "dynamic programming"],
    "strategy": "Use for problems requiring reversal, matching brackets, or maintaining order constraints. Consider monotonic stack variants."
  },
  {
    "tag": "string",
    "overview": "Character sequence problems involving pattern matching, manipulation, and analysis of textual data structures.",
    "patterns": ["hash table", "dynamic programming", "greedy", "simulation", "sliding window", "backtracking"],
    "related": ["hash table", "dynamic programming", "greedy", "simulation", "two pointers", "counting"],
    "strategy": "Consider character frequency maps and sliding window techniques. Pattern matching often benefits from KMP or Z-algorithm."
  },
  {
    "tag": "string matching",
    "overview": "Finding occurrences of pattern strings within text using efficient algorithms like KMP, Rabin-Karp, or Z-algorithm.",
    "patterns": ["string", "dynamic programming"],
    "related": [],
    "strategy": "Use KMP for single pattern matching, Aho-Corasick for multiple patterns. Rolling hash enables fast average-case matching."
  },
  {
    "tag": "strongly connected component",
    "overview": "Maximal set of vertices in directed graph where every vertex is reachable from every other vertex.",
    "patterns": ["eulerian circuit", "graph", "topological sort", "breadth-first search"],
    "related": [],
    "strategy": "Use Tarjan's or Kosaraju's algorithm for SCC detection. Essential for analyzing graph connectivity and cycles."
  },
  {
    "tag": "suffix array",
    "overview": "Sorted array of all suffixes of string, enabling efficient pattern matching and substring operations.",
    "patterns": ["string", "binary search"],
    "related": ["string", "binary search"],
    "strategy": "Build suffix array with O(n log n) algorithms. Use for multiple pattern queries and longest common substring problems."
  },
  {
    "tag": "topological sort",
    "overview": "Linear ordering of vertices in directed acyclic graph respecting edge directions, used in dependency resolution.",
    "patterns": ["graph", "breadth-first search", "depth-first search"],
    "related": ["graph", "breadth-first search", "depth-first search"],
    "strategy": "Use Kahn's algorithm (BFS-based) or DFS-based approach. Check for cycles before attempting topological ordering."
  },
  {
    "tag": "tree",
    "overview": "Hierarchical data structure with nodes connected by edges, forming connected acyclic graph structure.",
    "patterns": ["binary search tree", "binary tree", "dynamic programming", "depth-first search", "recursion"],
    "related": ["binary search tree", "binary tree", "dynamic programming", "depth-first search", "recursion"],
    "strategy": "Use recursion for natural tree traversal patterns. Consider iterative approaches with explicit stacks for optimization."
  },
  {
    "tag": "trie",
    "overview": "Tree-like data structure for storing strings with shared prefixes efficiently, enabling fast prefix operations.",
    "patterns": ["string", "design", "string matching"],
    "related": ["string", "design"],
    "strategy": "Build trie for prefix-related string problems. Each node represents character, paths from root represent complete strings."
  },
  {
    "tag": "two pointers",
    "overview": "Technique using two indices to traverse data structure from different positions or directions efficiently.",
    "patterns": ["array", "string", "sorting", "linked list", "sliding window"],
    "related": ["array", "string", "sorting", "linked list", "hash table"],
    "strategy": "Use for array/string problems needing O(n) time complexity. Consider fast-slow pointers for cycle detection in linked lists."
  },
  {
    "tag": "union find",
    "overview": "Data structure for tracking disjoint sets with efficient union and find operations for connectivity queries.",
    "patterns": ["graph", "topological sort", "depth-first search"],
    "related": [],
    "strategy": "Use path compression and union by rank for optimal performance. Excellent for connectivity problems and cycle detection."
  }
]